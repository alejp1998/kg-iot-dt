# -*- coding: utf-8 -*-
#----------------------------------------------------------------------------
# Created By  : Alejandro Jarabo
# Created Date: 2022-09-19
# Contact : ale.jarabo.penas@ericsson.com
# version ='1.0'
# ---------------------------------------------------------------------------
""" IoT Devices Definition
In this module, an IoT Device Class that implements an MQTT Client is defined. 
This class is then inherited by several device subclasses, such as robotic arms 
or air quality devices, which publish their simulated data updates to the MQTT network. 
The network messages are in JSON format and include the device class, which is linked to the 
device class' SDF description. If the Knowledge Graph Agent is unaware of the device, it can use 
the SDF description to learn about it.
"""
# ---------------------------------------------------------------------------
# Imports
from aux import *
# ---------------------------------------------------------------------------

# Server addresses
broker_addr = '0.0.0.0' # broker_addr = 'mosquitto'
broker_port = 8883

# Control messaging frequency
speedup_factor = 1

###################################
######## IOT DEVICES CLASS ########
###################################

# IoT Device Class to Inherit
class IoTDevice(Thread) :
    """IoTDevice: a class for MQTT-connected IoT devices

    This class is designed to be used as a base class for IoT devices that communicate with an MQTT broker. 
    It periodically publishes messages to a specified topic, and has callback functions to handle MQTT events such as connecting and disconnecting from the broker.
    The class inherits from the built-in Thread class to enable concurrent execution of the publishing loop.

    Attributes:
    topic (str): the topic to publish messages to
    devuuid (str): the device's UUID
    interval (float): the interval at which to publish messages (in seconds)
    modifier (float): a factor to personalize the data generated by the device
    print_logs (bool): if True, log messages will be printed to the console
    active (bool): indicates whether the device is active or not

    Methods:
    __init__(self, topic: str, devuuid: str, interval: float, modifier: float, print_logs: bool) -> None: initializes the attributes of the IoTDevice object, 
        assigns a unique identifier (UUID) to the object, and sets the active attribute to True.
    on_log(client, userdata, level, buf) -> None: a callback function that prints log messages.
    on_connect(self, client, userdata, flags, rc) -> None: a callback function that is called when the device connects to the MQTT broker. 
        It prints a message indicating that the device has connected and publishes a message to the device's topic.
    on_disconnect(self, client, userdata, rc) -> None: a callback function that is called when the device disconnects from the MQTT broker. 
        It prints a message indicating that the device has disconnected and publishes a message to the device's topic.
    gen_msg(self) -> str: generates a message to be published by the device.
    tic_behavior(self) -> None: defines the behavior of the device when it is active. It waits a random amount of time before starting and then periodically 
        publishes data when the device is active. It also prints log messages and processes callback functions.
    run(self) -> None: called when the IoTDevice object is started as a separate thread. It creates a new MQTT client instance and binds the callback functions. 
        It then connects the client to the MQTT broker and starts the tic_behavior method.
    """
    # Initialization
    def __init__(self, topic: str, devuuid: str, interval: float, modifier: float, print_logs: bool) :
        Thread.__init__(self)
        # Topic, publishing interval and log printing
        self.topic = topic
        self.interval = interval/speedup_factor
        self.modifier = modifier
        self.print_logs = print_logs
        # UUIDs
        self.uuid = re.sub(r'(\S{8})(\S{4})(\S{4})(\S{4})(.*)',r'\1-\2-\3-\4-\5',uuid.uuid4().hex) if devuuid=='' else devuuid  # assign unique identifier
        # Activation flag
        self.active = True
        
    # MQTT Callback Functions
    def on_log(client, userdata, level, buf):
        print("log: " + buf, kind='info')
        
    def on_connect(self, client, userdata, flags, rc):
        print(f'{self.dev_class}[{self.uuid[0:6]}] connected.', kind='success')
        msg = gen_header(self.dev_class,self.topic,self.uuid,category='CONNECTED')
        self.client.publish(self.topic,dumps(msg, indent=4))

    def on_disconnect(self, client, userdata, rc):
        print(f'{self.dev_class}[{self.uuid[0:6]}] disconnected.', kind='fail')
        msg = gen_header(self.dev_class,self.topic,self.uuid,category='DISCONNECTED')
        self.client.publish(self.topic,dumps(msg, indent=4))

    # Message generation function
    def gen_msg(self):
        msg = gen_header(self.dev_class,self.topic,self.uuid)
        msg['data'] = self.gen_data()
        return msg
    
    # Define tic behavior
    def tic_behavior(self):
        # Wait a random amount of time (up to 10secs) before starting
        time.sleep(random.uniform(0,10))
        # Periodically publish data when connected
        self.msg_count = 0
        tic = time.perf_counter()
        while True :
            if not self.active :
                print(f'{self.dev_class}[{self.uuid[0:6]}] inactive <N={self.msg_count} | T={tic-last_tic:.3f}s>', kind='') # print info
                while not self.active : time.sleep(5)
            self.msg_count += 1
            last_tic = tic
            tic = time.perf_counter()
            msg = self.gen_msg() # generate message with random data
            self.client.publish(self.topic,dumps(msg, indent=4)) # publish it
            print(f'({self.topic}) <- {self.dev_class}[{self.uuid[0:6]}] msg published <N={self.msg_count} | T={tic-last_tic:.3f}s>', kind='info') # print info
            if self.print_logs : print(msg) #print_device_data(msg['timestamp'],msg['data'])
            print('')
            self.client.loop() # run client loop for callbacks to be processed
            time.sleep(self.interval) # wait till next execution
        
    # Thread execution
    def run(self):
        self.client = mqtt_client.Client(self.uuid) # create new client instance

        self.client.on_log = self.on_log # bind callback fn
        self.client.on_connect = self.on_connect # bind callback fn
        self.client.on_disconnect = self.on_disconnect # bind callback fn

        self.client.connect(broker_addr, port=broker_port) # connect to the broker
        self.client.loop() # run client loop for callbacks to be processed
        
        self.tic_behavior() # start tic behavior

#########################################
######## PRODUCTION LINE DEVICES ########
#########################################

# CONVEYOR BELT
class ConveyorBelt(IoTDevice):
    """ConveyorBelt: a class representing a conveyor belt in a production line

    This class represents a conveyor belt in a production line and is a subclass of the IoTDevice class. 
    It has additional attributes and methods to simulate the time series behavior of the conveyor belt.

    Attributes:
    topic (str): the topic to publish messages to (inherited from IoTDevice)
    devuuid (str): the device's UUID (inherited from IoTDevice)
    interval (float): the interval at which to publish messages (in seconds) (inherited from IoTDevice)
    modifier (float): a factor to personalize the data generated by the device (inherited from IoTDevice)
    print_logs (bool): if True, log messages will be printed to the console (inherited from IoTDevice)
    active (bool): indicates whether the device is active or not (inherited from IoTDevice)
    dev_class (str): the class of the device ('ConveyorBelt')
    conveyor_belt (dict): a dictionary containing the current status, linear speed, rotational speed, and weight of the conveyor belt
    
    Methods:
    __init__(self, params: dict, topic: str = prodline_root, devuuid: str = '', interval: float = 2, modifier: float = 0.0, 
        print_logs: bool = False) -> None: initializes the attributes of the ConveyorBelt object and sets the initial values of the conveyor_belt attribute using the given parameters.
    gen_data(self) -> dict: simulates the time series behavior of the conveyor belt and returns an updated dictionary 
        containing the current status, linear speed, rotational speed, and weight of the conveyor belt.
    """
    # Initialization
    def __init__ (self,params,topic=prodline_root,devuuid='',interval=2,modifier=0.0,print_logs=False):
        IoTDevice.__init__(self,topic,devuuid,interval,modifier,print_logs)
        self.dev_class = 'ConveyorBelt'
        # Params for data generation
        mean, std = params['conv_belt']
        # Initial values
        self.conveyor_belt = {
            'status': True, 
            'linear_speed': sample_normal_mod(mean,std,self.modifier), 
            'rotational_speed': sample_normal_mod(mean*3,std,self.modifier), 
            'weight': sample_normal_mod(mean*100,std,self.modifier)
        }

    # Simulate time series behavior around initial values
    def gen_data(self) :
        # CONVEYOR BELT MODULE
        self.conveyor_belt['status'] = coin(0.95) if self.conveyor_belt['status'] else coin(0.2)
        self.conveyor_belt['linear_speed'] = get_new_sample(self.conveyor_belt['linear_speed'])
        self.conveyor_belt['rotational_speed'] = get_new_sample(self.conveyor_belt['rotational_speed'])
        self.conveyor_belt['weight'] = get_new_sample(self.conveyor_belt['weight'])
        
        # Modifications based on status value
        conveyor_belt_copy = self.conveyor_belt.copy()
        conveyor_belt_copy['linear_speed'] = self.conveyor_belt['linear_speed'] if self.conveyor_belt['status'] else 0.0
        conveyor_belt_copy['rotational_speed'] = self.conveyor_belt['rotational_speed'] if self.conveyor_belt['status'] else 0.0
        
        # Return updated data dictionary
        return {'conveyor_belt' : conveyor_belt_copy}

# TAG SCANNER
class TagScanner(IoTDevice):
    """TagScanner: a class representing an RFID tag scanner in a production line
    ...

    Attributes:
    ...
    dev_class (str): the class of the device ('TagScanner')
    rfid_scanner (dict): a dictionary containing the current product ID and process ID of the RFID tag being scanned

    Methods: ...
    """
    # Initialization
    def __init__(self,topic=prodline_root,devuuid='',interval=5, modifier=0.0, print_logs=False):
        IoTDevice.__init__(self,topic,devuuid,interval,modifier,print_logs)
        self.dev_class = 'TagScanner'
        # Initial values
        self.rfid_scanner = {
            'product_id' : random.randint(0,10),
            'process_id' : random.randint(0,10)
        }

    # Simulate time series behavior around initial values
    def gen_data(self) :
        # RFID SCANNER MODULE
        self.rfid_scanner['product_id'] = self.rfid_scanner['product_id'] if coin(0.7) else random.randint(0,10)
        self.rfid_scanner['process_id'] = self.rfid_scanner['process_id'] if coin(0.7) else random.randint(0,10)
        
        # Return updated data dictionary
        return {'rfid_scanner' : self.rfid_scanner}

# PRODUCTION CONTROL
class ProductionControl(IoTDevice):
    """ProductionControl: a class representing a production control system in a production line
    ...

    Attributes:
    ...
    dev_class (str): the class of the device ('ProductionControl')
    production_control (dict): a dictionary containing the current production status of the production line

    Methods: ...
    """
    # Initialization
    def __init__(self,topic=prodline_root,devuuid='',interval=5, modifier=0.0, print_logs=False):
        IoTDevice.__init__(self,topic,devuuid,interval,modifier,print_logs)
        self.dev_class = 'ProductionControl'
        # Initial values
        self.production_control = {'production_status' : True}

    # Simulate time series behavior around initial values
    def gen_data(self) :
        # PRODUCTION CONTROL MODULE
        self.production_control['production_status'] = coin(0.95) if self.production_control['production_status'] else coin(0.2)
        
        # Return updated data dictionary
        return {'production_control' : self.production_control}

# REPAIR CONTROL
class RepairControl(IoTDevice):
    """RepairControl: a class representing a repair control system in a production line
    ...

    Attributes:
    ...
    dev_class (str): the class of the device ('RepairControl')
    repair_control (dict): a dictionary containing the current repair status of the production line

    Methods: ...
    """
    # Initialization
    def __init__(self,topic=prodline_root,devuuid='',interval=5, modifier=0.0, print_logs=False):
        IoTDevice.__init__(self,topic,devuuid,interval,modifier,print_logs)
        self.dev_class = 'RepairControl'
        # Initial values
        self.repair_control = {'repair_status': 2}
        
    # Simulate time series behavior around initial values
    def gen_data(self) :
        # REPAIR CONTROL MODULE
        self.repair_control['repair_status'] = self.repair_control['repair_status'] if coin(0.8) else (self.repair_control['repair_status'] + 1)%2
        
        # Return updated data dictionary
        return {'repair_control' : self.repair_control}
                  
# PRODUCT CONFIG SCANNER
class ConfigurationScanner(IoTDevice):
    """ConfigurationScanner: a class representing a configuration scanner in a production line

    Attributes:
    ...
    dev_class (str): the class of the device ('ConfigurationScanner')

    Methods: ...
    """
    # Initialization
    def __init__(self,topic=prodline_root,devuuid='',interval=5, modifier=0.0, print_logs=False):
        IoTDevice.__init__(self,topic,devuuid,interval,modifier,print_logs)
        self.dev_class = 'ConfigurationScanner'
        # No initial values since this device requires no memory for data generation

    # Simulate time series behavior around initial values
    def gen_data(self) :
        return {
            'left_cam': {'config_status' : coin(0.975)},
            'right_cam': {'config_status' : coin(0.975)},
            'front_cam': {'config_status' : coin(0.975)},
            'back_cam': {'config_status' : coin(0.975)},
            'top_cam': {'config_status' : coin(0.975)},
            'bottom_cam': {'config_status' : coin(0.975)}
        }

# PRODUCT QUALITY SCANNER
class QualityScanner(IoTDevice):
    """QualityScanner: a class representing a quality scanner in a production line
    ...

    Attributes:
    ...
    dev_class (str): the class of the device ('QualityScanner')

    Methods: ...
    """
    # Initialization
    def __init__(self,topic=prodline_root,devuuid='',interval=5, modifier=0.0, print_logs=False):
        IoTDevice.__init__(self,topic,devuuid,interval,modifier,print_logs)
        self.dev_class = 'QualityScanner'
        # No initial values since this device requires no memory for data generation

    # Simulate time series behavior around initial values
    def gen_data(self) :
        return {
            'left_cam': {'quality_status' : coin(0.975)},
            'right_cam': {'quality_status' : coin(0.975)},
            'front_cam': {'quality_status' : coin(0.975)},
            'back_cam': {'quality_status' : coin(0.975)},
            'top_cam': {'quality_status' : coin(0.975)},
            'bottom_cam': {'quality_status' : coin(0.975)}
        }

# FAULT NOTIFIER
class FaultNotifier(IoTDevice):
    """FaultNotifier: a class representing a fault notifier in a production line
    ...

    Attributes:
    ...
    dev_class (str): the class of the device ('FaultNotifier')
    fault_notifier (dict): a dictionary containing the alarm status of the fault notifier

    Methods: ...
    """
    # Initialization
    def __init__(self,topic=prodline_root,devuuid='',interval=5, modifier=0.0, print_logs=False):
        IoTDevice.__init__(self,topic,devuuid,interval,modifier,print_logs)
        self.dev_class = 'FaultNotifier'
        # Initial data
        self.fault_notifier = {'alarm': False}

    # Simulate time series behavior around initial values
    def gen_data(self) :
        # FAULT NOTIFIER MODULE
        self.fault_notifier['alarm'] = coin(0.05) if not self.fault_notifier['alarm'] else coin(0.7)
        
        # Return updated data dictionary
        return {'fault_notifier': self.fault_notifier}

# POSE DETECTOR
class PoseDetector(IoTDevice):
    """PoseDetector: a class representing a pose detector in a production line
    ...

    Attributes:
    ...
    dev_class (str): the class of the device ('PoseDetector')
    params (dict): a dictionary of parameters for generating data

    Methods: ...
    """
    # Initialization
    def __init__(self,params,topic=prodline_root,devuuid='',interval=3, modifier=0.0, print_logs=False):
        IoTDevice.__init__(self,topic,devuuid,interval,modifier,print_logs)
        self.dev_class = 'PoseDetector'
        # Params for data generation
        self.params = params['pose_det']

    # Simulate time series behavior around initial values
    def gen_data(self) :
        # Unpack params and sample time
        offset, A, T, phi = self.params
        # Return updated data dictionary
        return {
            'pose_detection_cam':{
                'x_position' : sample_triangular(offset,A,T,phi),
                'y_position' : sample_triangular(offset+1,A*2,T/2,phi),  
                'z_position' : sample_triangular(offset-1,A/2,T*2,phi),
                'roll_orientation' : sample_triangular(offset+np.pi/2,A,T,phi), 
                'pitch_orientation' : sample_triangular(offset+6*np.pi/4,A*2,T/2,phi), 
                'yaw_orientation' : sample_triangular(offset-6*np.pi/4,A/2,T*2,phi)
            }
        }

# PIECE DETECTOR
class PieceDetector(IoTDevice):
    """PieceDetector: a class representing a piece detector in a production line

    Attributes:
    ...
    dev_class (str): the class of the device ('PieceDetector')
    params (dict): the parameters for generating data for the piece detector
    piece_id (int): the current ID of the detected piece

    Methods: ...
    """
    # Initialization
    def __init__(self,params,topic=prodline_root,devuuid='',interval=3, modifier=0.0, print_logs=False):
        IoTDevice.__init__(self,topic,devuuid,interval,modifier,print_logs)
        self.dev_class = 'PieceDetector'
        # Params for data generation
        self.params = params['piece_det']
        self.piece_id = random.randint(0,6)

    # Simulate time series behavior around initial values
    def gen_data(self) :
        # Unpack params and sample time
        offset, A, T, phi = self.params
        # Return updated data dictionary
        return {
            'piece_detection_cam':{
                'piece_id' : self.piece_id if coin(0.7) else random.randint(0,6),
                'x_position' : sample_sawtooth(offset,A,T,phi),
                'y_position' : sample_sawtooth(offset+1,A*2,T/2,phi),  
                'z_position' : sample_sawtooth(offset-1,A/2,T*2,phi),
                'roll_orientation' : sample_sawtooth(offset+np.pi/2,A,T,phi), 
                'pitch_orientation' : sample_sawtooth(offset+6*np.pi/4,A*2,T/2,phi), 
                'yaw_orientation' : sample_sawtooth(offset-6*np.pi/4,A/2,T*2,phi)
            }
        }

# PICK UP ROBOT
class PickUpRobot(IoTDevice):
    """PickUpRobot: a class representing a pick-up robot in a production line
    ...

    Attributes:
    ...
    dev_class (str): the class of the device ('PickUpRobot')
    params (dict): parameters for data generation
    actuator_status (bool): indicates whether the robot's actuator is in the open or closed position

    Methods: ...
    """
    # Initialization
    def __init__(self,params,topic=prodline_root,devuuid='',interval=3, modifier=0.0, print_logs=False):
        IoTDevice.__init__(self,topic,devuuid,interval,modifier,print_logs)
        self.dev_class = 'PickUpRobot'
        # Params for data generation
        self.params = params['pickup']
        self.actuator_status = False

    # Simulate time series behavior around initial values
    def gen_data(self) :
        self.actuator_status = coin(0.2) if not self.actuator_status else coin(0.7)
        # Unpack params and sample time
        offset, A, T, phi = self.params
        # Return updated data dictionary
        return gen_robot_data(offset,A,T,phi+random.normal(),self.actuator_status)

# CLAMPING ROBOT
class ClampingRobot(IoTDevice):
    """ClampingRobot: a class representing a clamping robot in a production line
    ...

    Attributes:
    ...
    dev_class (str): the class of the device ('ClampingRobot')
    params (dict): parameters for data generation
    actuator_status (bool): indicates whether the robot's actuator is active

    Methods: ...
    """
    # Initialization
    def __init__(self,params,topic=prodline_root,devuuid='',interval=3, modifier=0.0, print_logs=False):
        IoTDevice.__init__(self,topic,devuuid,interval,modifier,print_logs)
        self.dev_class = 'ClampingRobot'
        # Params for data generation
        self.params = params['clamping']
        self.actuator_status = False

    # Simulate time series behavior around initial values
    def gen_data(self) :
        self.actuator_status = coin(0.2) if not self.actuator_status else coin(0.7)
        # Unpack params and sample time
        offset, A, T, phi = self.params
        # Return updated data dictionary
        return gen_robot_data(offset,A,T,phi+random.normal(),self.actuator_status)

# DRILLING ROBOT
class DrillingRobot(IoTDevice):
    """DrillingRobot: a class representing a drilling robot in a production line
    ...

    Attributes:
    ...
    dev_class (str): the class of the device ('DrillingRobot')
    params (dict): parameters for data generation
    actuator_status (bool): indicates whether the robot's actuator is active

    Methods: ...
    """
    # Initialization
    def __init__(self,params,topic=prodline_root,devuuid='',interval=3, modifier=0.0, print_logs=False):
        IoTDevice.__init__(self,topic,devuuid,interval,modifier,print_logs)
        self.dev_class = 'DrillingRobot'
        # Params for data generation
        self.params = params['drilling']
        self.actuator_status = False

    # Simulate time series behavior around initial values
    def gen_data(self) :
        self.actuator_status = coin(0.2) if not self.actuator_status else coin(0.7)
        # Unpack params and sample time
        offset, A, T, phi = self.params
        t = time.perf_counter()
        # Return updated data dictionary
        return gen_robot_data(offset,A,T,phi+random.normal(),self.actuator_status)

# MILLING ROBOT
class MillingRobot(IoTDevice):
    """MillingRobot: a class representing a milling robot in a production line
    ...
    
    Attributes:
    ...
    dev_class (str): the class of the device ('MillingRobot')
    params (dict): parameters for data generation
    actuator_status (bool): indicates whether the robot's actuator is active

    Methods: ...
    """
    # Initialization
    def __init__(self,params,topic=prodline_root,devuuid='',interval=3, modifier=0.0, print_logs=False):
        IoTDevice.__init__(self,topic,devuuid,interval,modifier,print_logs)
        self.dev_class = 'MillingRobot'
        # Params for data generation
        self.params = params['pickup']
        self.actuator_status = False

    # Simulate time series behavior around initial values
    def gen_data(self) :
        self.actuator_status = coin(0.2) if not self.actuator_status else coin(0.7)
        # Unpack params and sample time
        offset, A, T, phi = self.params
        t = time.perf_counter()
        # Return updated data dictionary
        return gen_robot_data(offset,A,T,phi+random.normal(),self.actuator_status)


################################################
######## SAFETY / ENVIRONMENTAL DEVICES ########
################################################

# AIR QUALITY
class AirQuality(IoTDevice):
    """AirQuality: a class for an air quality device that inherits from the IoTDevice class.

    This class simulates an air quality device that periodically publishes data updates to the MQTT network. 
    It has a `gen_data` method that generates data based on ground truth values.

    Attributes:
    ...
    ground_truth (Dict): a dictionary of ground truth values for data generation

    Methods: ...
    """
    # Initialization
    def __init__(self, ground_truth: Dict, topic: str = safetyenv_root, devuuid: str = '', interval: float = 2, modifier: float = 0.0, print_logs: bool = False):
        IoTDevice.__init__(self,topic,devuuid,interval,modifier,print_logs)
        self.dev_class = 'AirQuality'
        # Variables for data generation
        self.gt = ground_truth
        
    # New measurement around ground truth values
    def gen_data(self) -> Dict:
        return {
            'temperature_sensor' : {'temperature': sample_normal_mod(self.gt.get('temperature'),modifier=self.modifier)},
            'humidity_sensor' : {'humidity': sample_normal_mod(self.gt.get('humidity'),modifier=self.modifier)},
            'pressure_sensor' : {'pressure': sample_normal_mod(self.gt.get('pressure'),modifier=self.modifier)},
            'air_quality_sensor' : {
                'pm1': sample_normal_mod(self.gt.get('pm1'),modifier=self.modifier), 
                'pm25': sample_normal_mod(self.gt.get('pm25'),modifier=self.modifier), 
                'pm10': sample_normal_mod(self.gt.get('pm10'),modifier=self.modifier)
            }
        }

# AIR QUALITY MODIFIED
class AirQualitySimplified(IoTDevice):
    """AirQualitySimplified: a class for an air quality simplified device that inherits from the IoTDevice class.
    ...
    
    Attributes:
    ...
    ground_truth (Dict[str, float]): a dictionary of ground truth values for data generation

    Methods: ...
    """
    # Initialization
    def __init__(self, ground_truth: Dict, topic: str = safetyenv_root, devuuid: str = '', interval: float = 2, modifier: float = 0.0, print_logs: bool = False):
        IoTDevice.__init__(self,topic,devuuid,interval,modifier,print_logs)
        self.dev_class = 'AirQualitySimplified'
        # Variables for data generation
        self.gt = ground_truth

    # New measurement around ground truth values
    def gen_data(self) -> Dict :
        return {
            'temperature_humidity_sensor' : {
                'temperature' : sample_normal_mod(self.gt.get('temperature'),modifier=self.modifier),
                'humidity' : sample_normal_mod(self.gt.get('humidity'),modifier=self.modifier)
            },
            'air_quality_sensor' : {
                'pm25' : sample_normal_mod(self.gt.get('pm25'),modifier=self.modifier),
                'pm10' : sample_normal_mod(self.gt.get('pm10'),modifier=self.modifier)
            }
        }

# NOISE SENSOR
class NoiseSensor(IoTDevice):
    """A class representing a noise sensor device that inherits from IoTDevice.
    ...
    """
    
    # Initialization
    def __init__(self, topic: str = safetyenv_root, devuuid: str = '', interval: float = 5, modifier: float = 0.0, print_logs: bool = False):
        IoTDevice.__init__(self,topic,devuuid,interval,modifier,print_logs)
        self.dev_class = 'NoiseSensor'
        
    # Simulate time series behavior around initial values
    def gen_data(self) -> Dict :
        return {'noise_sensor' : {'noise' : sample_normal_mod(70,2,self.modifier)}}

# SMOKE SENSOR
class SmokeSensor(IoTDevice):
    """A class representing a smoke sensor device that inherits from IoTDevice.
    ...
    """
    ## Initialization
    def __init__(self, topic: str = safetyenv_root, devuuid: str = '', interval: float = 5, modifier: float = 0.0, print_logs: bool = False):
        IoTDevice.__init__(self,topic,devuuid,interval,modifier,print_logs)
        self.dev_class = 'SmokeSensor'
        # Initial values
        self.smoke_sensor = {'smoke': False}
        
    # Simulate time series behavior around initial values
    def gen_data(self) -> Dict :
        self.smoke_sensor['smoke'] = coin(0.05) if self.smoke_sensor['smoke'] else coin(0.7)
        return {'smoke_sensor' : self.smoke_sensor}

# SEISMIC SENSOR
class SeismicSensor(IoTDevice):
    """A class representing a seismic sensor device that inherits from IoTDevice.
    ...
    """
    # Initialization
    def __init__(self, topic: str = safetyenv_root, devuuid: str = '', interval: float = 5, modifier: float = 0.0, print_logs: bool = False):
        IoTDevice.__init__(self,topic,devuuid,interval,modifier,print_logs)
        self.dev_class = 'SeismicSensor'
        # Initial values
        self.seismic_sensor = {'intensity': random.randint(0,1)}
        
    # Simulate time series behavior around initial values
    def gen_data(self) -> Dict :
        self.seismic_sensor['intensity'] = random.randint(0,1) if coin(0.95) else random.randint(2,8)
        return {'seismic_sensor' : self.seismic_sensor}

# RAIN SENSOR
class RainSensor(IoTDevice):
    """A class representing a rain sensor device that inherits from IoTDevice.
    ...
    """
    # Initialization
    def __init__(self, ground_truth: Dict, topic: str = safetyenv_root, devuuid: str = '', interval: float = 5, modifier: float = 0.0, print_logs: bool = False):
        IoTDevice.__init__(self,topic,devuuid,interval,modifier,print_logs)
        self.dev_class = 'RainSensor'
        # Variables for data generation
        self.gt = ground_truth
        
    # New measurement around ground truth values
    def gen_data(self) -> Dict :
        return {'rain_sensor' : {'cumdepth' : sample_normal_mod(self.gt.get('rain_cumdepth'),modifier=self.modifier)}}

# WIND SENSOR
class WindSensor(IoTDevice):
    """A class representing a wind sensor device that inherits from IoTDevice.
    ...
    """
    # Initialization
    def __init__(self, ground_truth: Dict, topic: str = safetyenv_root, devuuid: str = '', interval: float = 5, modifier: float = 0.0, print_logs: bool = False):
        IoTDevice.__init__(self,topic,devuuid,interval,modifier,print_logs)
        self.dev_class = 'WindSensor'
        # Variables for data generation
        self.gt = ground_truth
        
    # New measurement around ground truth values
    def gen_data(self) -> Dict :
        return {
            'wind_sensor' : {
                'speed' : sample_normal_mod(self.gt.get('wind_speed'),modifier=self.modifier),
                'direction' : sample_normal_mod(self.gt.get('wind_direction'),modifier=self.modifier)
            }
        }

# INDOORS ALARM
class IndoorsAlarm(IoTDevice):
    """A class representing a indoors alarm device that inherits from IoTDevice.
    ...
    """
    # Initialization
    def __init__(self, topic: str = safetyenv_root, devuuid: str = '', interval: float = 5, modifier: float = 0.0, print_logs: bool = False):
        IoTDevice.__init__(self,topic,devuuid,interval,modifier,print_logs)
        self.dev_class = 'IndoorsAlarm'
        
    # Simulate time series behavior around initial values
    def gen_data(self) -> Dict :
        return {
            'air_quality_alarm' : {'status' : coin(0.005)},
            'temperature_alarm' : {'status' : coin(0.005)},
            'humidity_alarm' : {'status' : coin(0.005)},
            'fire_alarm' : {'status' : coin(0.005)},
            'seismic_alarm' : {'status' : coin(0.005)}
        }

# OUTDOORS ALARM
class OutdoorsAlarm(IoTDevice):
    """A class representing a outdoors alarm device that inherits from IoTDevice.
    ...
    """
    # Initialization
    def __init__(self, topic: str = safetyenv_root, devuuid: str = '', interval: float = 5, modifier: float = 0.0, print_logs: bool = False):
        IoTDevice.__init__(self,topic,devuuid,interval,modifier,print_logs)
        self.dev_class = 'OutdoorsAlarm'
        
    # Simulate time series behavior around initial values
    def gen_data(self) -> Dict :
        return {
            'air_quality_alarm' : {'status' : coin(0.005)},
            'temperature_alarm' : {'status' : coin(0.005)},
            'humidity_alarm' : {'status' : coin(0.005)},
            'rain_alarm' : {'status' : coin(0.005)},
            'wind_alarm' : {'status' : coin(0.005)}
        }
